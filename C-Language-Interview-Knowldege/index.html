<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">





  <meta name="keywords" content="C," />










<meta name="description" content="整理了一些C语言面试中的基础知识，包括预处理阶段、主要关键字的用法、局部变量和全局变量、结构体与联合体、数据类型和函数、内存分配回收等。 预处理什么是预编译？何时需要预编译？（1）预编译又称预处理，是做些代码文本的替换工作，即程序执行前的一些预处理工作。主要处理#开头的指令，如拷贝#include包含的文件代码、替换#">
<meta name="keywords" content="C">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言面试基础知识整理">
<meta property="og:url" content="http://weijuanran.cn/C-Language-Interview-Knowldege/index.html">
<meta property="og:site_name" content="weijuanran">
<meta property="og:description" content="整理了一些C语言面试中的基础知识，包括预处理阶段、主要关键字的用法、局部变量和全局变量、结构体与联合体、数据类型和函数、内存分配回收等。 预处理什么是预编译？何时需要预编译？（1）预编译又称预处理，是做些代码文本的替换工作，即程序执行前的一些预处理工作。主要处理#开头的指令，如拷贝#include包含的文件代码、替换#define定义的宏、条件编译#if等。（2）何时需要预编译：">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-05-13T07:53:21.746Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C语言面试基础知识整理">
<meta name="twitter:description" content="整理了一些C语言面试中的基础知识，包括预处理阶段、主要关键字的用法、局部变量和全局变量、结构体与联合体、数据类型和函数、内存分配回收等。 预处理什么是预编译？何时需要预编译？（1）预编译又称预处理，是做些代码文本的替换工作，即程序执行前的一些预处理工作。主要处理#开头的指令，如拷贝#include包含的文件代码、替换#define定义的宏、条件编译#if等。（2）何时需要预编译：">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://weijuanran.cn/C-Language-Interview-Knowldege/"/>





  <title>C语言面试基础知识整理 | weijuanran</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">weijuanran</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">smile towards</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://weijuanran.cn/C-Language-Interview-Knowldege/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weijuanran">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weijuanran">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C语言面试基础知识整理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-12T20:14:27+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-Language/" itemprop="url" rel="index">
                    <span itemprop="name">C Language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>整理了一些C语言面试中的基础知识，包括预处理阶段、主要关键字的用法、局部变量和全局变量、结构体与联合体、数据类型和函数、内存分配回收等。</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h3 id="什么是预编译？何时需要预编译？"><a href="#什么是预编译？何时需要预编译？" class="headerlink" title="什么是预编译？何时需要预编译？"></a>什么是预编译？何时需要预编译？</h3><p>（1）预编译又称预处理，是做些代码文本的替换工作，即程序执行前的一些预处理工作。<font color="#CD0000" size="3">主要处理#开头的指令，如拷贝#include包含的文件代码、替换#define定义的宏、条件编译#if等</font>。<br>（2）何时需要预编译：<br><a id="more"></a><br>a.总是使用不经常改动的大型代码体；<br>b.程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。</p>
<h3 id="写一个“标准”宏，这个宏输入两个参数并返回较小的一个"><a href="#写一个“标准”宏，这个宏输入两个参数并返回较小的一个" class="headerlink" title="写一个“标准”宏，这个宏输入两个参数并返回较小的一个"></a>写一个“标准”宏，这个宏输入两个参数并返回较小的一个</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MIN(x, y) ((x)&lt;(y)?(x):(y))  //注意结尾没有;</span><br></pre></td></tr></table></figure>
<h3 id="与-的作用？"><a href="#与-的作用？" class="headerlink" title="#与##的作用？"></a>#与##的作用？</h3><p><font color="#CD0000" size="3">#是把宏参数转化为字符串的运算符，##是把两个宏参数连接的运算符。</font><br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define STR(arg) #arg          //则宏STR(hello)展开时为”hello”</span><br><span class="line">#define NAME(y) name_y      //则宏NAME(1)展开时仍为name_y</span><br><span class="line">#define NAME(y) name_##y    //则宏NAME(1)展开为name_1</span><br><span class="line">#define DECLARE(name, type) typename##_##type##_type，</span><br><span class="line">//则宏DECLARE(val, int)展开为int val_int_type</span><br></pre></td></tr></table></figure></p>
<h3 id="如何避免头文件被重复包含？"><a href="#如何避免头文件被重复包含？" class="headerlink" title="如何避免头文件被重复包含？"></a>如何避免头文件被重复包含？</h3><p>例如，为避免头文件my_head.h被重复包含，可在其中<font color="#CD0000" size="3">使用条件编译</font>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _MY_HEAD_H</span><br><span class="line">#define _MY_HEAD_H    /*空宏*/</span><br><span class="line">/*其他语句*/</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<h3 id="include-与-include-“file-h”的区别？"><a href="#include-与-include-“file-h”的区别？" class="headerlink" title="#include 与 #include “file.h”的区别？"></a>#include<file.h> 与 #include “file.h”的区别？</file.h></h3><p>前者是从Standard Library的路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="register："><a href="#register：" class="headerlink" title="register："></a>register：</h3><p>（1）register关键字的作用：<br>请求CPU尽可能让变量的值保存在CPU内部的寄存器中，减去CPU从内存中抓取数据的时间，提高程序运行效率。<br>（2）register作用的实现原理：<br>扩展：CPU组成，计算机系统组成，数据处理流程 。<br>（3）什么时候使用register?<br>一般，我们<font color="#CD0000" size="3">将频繁被访问的变量，用register修饰</font>。<br>（因为CPU内存资源是有限的，是稀缺的，不可能将所有变量都声明为register变量）<br>（4）使用register关键字应注意什么？</p>
<p><font color="#CD0000" size="3">a.只有局部变量才可以被声明用register修饰；</font><br>（register不能修饰全局变量和函数的原因：全局变量可能被多个进程访问，而用register修饰的变量，只能被当前进程访问）</p>
<p><font color="#CD0000" size="3">b.不能用取地址获取用register修饰的变量的地址；</font><br>（原因：变量保存在寄存器中，而取地址获取的地址的是内存的地址）</p>
<p><font color="#CD0000" size="3">c.用register修饰的变量一定要是CPU所接受的数据类型。 </font></p>
<h3 id="static："><a href="#static：" class="headerlink" title="static："></a>static：</h3><p>（1）static关键字的作用：</p>
<p><font color="#CD0000" size="3">static既可以修饰变量，也可以修饰函数，修饰变量时，既可以修饰局部，也可修饰全局。</font><br>static修饰静态局部变量，延长变量的生命周期，直至程序结束，这个变量才释放；<br>static修饰全局变量，使其只可在本文件可访问，其他文件不可见；<br>（static修饰的变量都保存在数据段静态数据区中，未初始化时，系统将默认初始化为0）<br>static修饰函数，使其只可在本文件可调用，其他文件不可调用；<br> （2）什么时候使用static修饰变量？<br>当希望一个变量直至程序结束才释放时，用static修饰静态局部变量；<br>当希望一个全局变量只可在本文件可访问，其他文件不可见时，用Static修饰全局变量；<br>当希望一个函数只可在本文件可调用，其他文件不可调用时，用Static修饰函数；</p>
<h3 id="extern："><a href="#extern：" class="headerlink" title="extern："></a>extern：</h3><p>（1）extern关键字的作用：</p>
<p><font color="#CD0000" size="3">extern用来外部声明一个全局变量</font>，这个全局变量在另一个文件中被定义。<br> （2）使用extern关键字应注意什么？<br>标明数据类型，例：extern int count；<br> （3）什么时候使用extern修饰变量？<br>在a.c文件中想使用b.c文件中的全局变量时，用extern 外部声明。<br>（4）用于extern  “C”<br>当文件为CPP文件时，通过extern “C”告诉C++编译器，extern “C”{}里包含的函数都用C的方式来编译：<br>a.可以是单一语句；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; double sqrt(double);</span><br></pre></td></tr></table></figure></p>
<p>b.可以是复合语句, 相当于复合语句中的声明都加了extern “C”；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    double sqrt(double);</span><br><span class="line">    int min(int, int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>c.可以包含头文件，相当于头文件中的声明都加了extern “C”；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    #include &lt;cmath&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>d.不可以将extern “C” 添加在函数内部；<br>e.如果函数有多个声明，可以都加extern “C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则；<br>f.除extern “C”, 还有extern “FORTRAN” 等。</p>
<h3 id="const："><a href="#const：" class="headerlink" title="const："></a>const：</h3><p>（1）const关键字的作用：<br>const修饰变量,是这个变量变成<font color="#CD0000" size="3">只读变量</font>，变量对应的空间的值是可变的，但不能用变量名来修改空间中的值。<br> （2）使用const关键字应注意什么？<br>使用const关键字修饰的变量，<font color="#CD0000" size="3">一定要对变量进行初始化</font>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *const p = &amp;num;   p++ ✘</span><br><span class="line">const int *p = &amp;num;   (*p)++ ✘</span><br><span class="line">int const *p = &amp;num;   (*p)++ ✘</span><br></pre></td></tr></table></figure></p>
<p>(离谁进，谁就不可以改变)<br> （3）什么时候使用const修饰变量？</p>
<p><font color="#CD0000" size="3">a.声明常变量，使得指定的变量不能被修改；</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int a = 5;/*a的值一直为5，不能被改变*/</span><br><span class="line">const int b; b = 10;/*b的值被赋值为10后，不能被改变*/</span><br><span class="line">const int *ptr; /*ptr为指向整型常量的指针，ptr的值可以修改，但不能修改其所指向的值*/</span><br><span class="line">int *const ptr;/*ptr为指向整型的常量指针，ptr的值不能修改，但可以修改其所指向的值*/</span><br><span class="line">const int *const ptr;/*ptr为指向整型常量的常量指针，ptr及其指向的值都不能修改*/</span><br></pre></td></tr></table></figure></p>
<p><font color="#CD0000" size="3">b.修饰函数形参，使得形参在函数内不能被修改，表示输入参数；</font><br>如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fun(const int a);或</span><br><span class="line">int fun(const char *str);</span><br></pre></td></tr></table></figure></p>
<p><font color="#CD0000" size="3">c.修饰函数返回值，使得函数的返回值不能被修改。</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *getstr(void);使用：const *str= getstr();</span><br><span class="line">const int getint(void);  使用：const int a =getint();</span><br></pre></td></tr></table></figure></p>
<p>（4）const与#define 相比，有何优点？<br>（1）<font color="#CD0000" size="3">const作用：定义常量、修饰函数参数、修饰函数返回值。</font><br>被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。<br>（2）<font color="#CD0000" size="3">const 常量有数据类型，而宏常量没有数据类型</font>。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。<br>（3）有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</p>
<h3 id="typedef："><a href="#typedef：" class="headerlink" title="typedef："></a>typedef：</h3><p>（1）typedef关键字的作用：<br>声明一个已经存在的数据类型的同义字，给数据类型定义一个<font color="#CD0000" size="3">新名字</font>，提高了移植性；简化复杂的类型声明，提高编码效率；解释数据类型的作用。</p>
<h3 id="voliate："><a href="#voliate：" class="headerlink" title="voliate："></a>voliate：</h3><p>（1）voliate关键字的作用：<br>volatile指定的变量可能被系统、硬件、进程/线程改变，<font color="#CD0000" size="3">强制编译器每次从内存中取得该变量的值，而不是从被优化后的寄存器中读取</font>。<br>简单来说，就是自己所定义的变量在程序运行过程中一直会变，如果希望这个值被正确处理，就需要每次从内存中去读这个值，这样就不会有错误了。<br>（2）什么情况下用volatile关键字？<br>a.中断服务程序中修改的供其他程序检测的变量需要加volatile；<br>b.多任务环境下各任务间共享的标志应该加volatile；<br>c.存储器映射的硬件寄存器通常也要加volatile说明，因此每次对它的读写都可能有不同意义。<br>（3）一个参数既可以是const还可以是volatile吗？<br>可以，例如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。<br>（4）一个指针可以是volatile 吗？<br>可以，尽管这并不常见。例如当一个中服务子程序修该一个指向buffer的指针时。</p>
<h3 id="inline："><a href="#inline：" class="headerlink" title="inline："></a>inline：</h3><p>（1）inline关键字的作用：<br>内联inline是给编译器的优化提示，如果一个函数被编译成inline的话，那么就<font color="#CD0000" size="3">会把函数里面的代码直接插入到调用这个函数的地方</font>，而不是用调用函数的形式。<br>（2）使用inline关键字应注意什么？<br>内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p>
<h3 id="sizeof："><a href="#sizeof：" class="headerlink" title="sizeof："></a>sizeof：</h3><p>（1）sizeof关键字的作用：<br>sizeof是在编译阶段处理，且不能被编译为机器码。sizeof的结果等于对象或类型所占的内存字节数。sizeof的返回值类型为size_t。<br>（2）sizeof的取值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">变量：int a;  sizeof(a)为4；</span><br><span class="line">指针：int *p;  sizeof(p)为4；</span><br><span class="line">数组：int b[10]; sizeof(b)为数组的大小，4*10；int c[0]; sizeof(c)等于0；</span><br><span class="line">结构体：struct (int a; char ch;)s1; sizeof(s1)为8 ，因为结构体字节需要对齐。</span><br><span class="line">注意：不能对结构体中的位域成员使用sizeof</span><br><span class="line">sizeof(void)等于1</span><br><span class="line">sizeof(void *)等于4</span><br></pre></td></tr></table></figure></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="全局变量和局部变量在内存中的区别？"><a href="#全局变量和局部变量在内存中的区别？" class="headerlink" title="全局变量和局部变量在内存中的区别？"></a>全局变量和局部变量在内存中的区别？</h3><p><font color="#CD0000" size="3">全局变量储存在静态数据区，局部变量在堆栈中。</font></p>
<h3 id="局部变量能否和全局变量重名？"><a href="#局部变量能否和全局变量重名？" class="headerlink" title="局部变量能否和全局变量重名？"></a>局部变量能否和全局变量重名？</h3><p>能，<font color="#CD0000" size="3">局部会屏蔽全局</font>。要用全局变量，需要使用”::”。<br>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内</p>
<h3 id="如何引用一个已经定义过的全局变量？"><a href="#如何引用一个已经定义过的全局变量？" class="headerlink" title="如何引用一个已经定义过的全局变量？"></a>如何引用一个已经定义过的全局变量？</h3><p><font color="#CD0000" size="3">可以用引用头文件的方式，也可以用extern关键字</font>，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。</p>
<h3 id="全局变量能否定义在被多个-C文件包含的头文件中？"><a href="#全局变量能否定义在被多个-C文件包含的头文件中？" class="headerlink" title="全局变量能否定义在被多个.C文件包含的头文件中？"></a>全局变量能否定义在被多个.C文件包含的头文件中？</h3><p><font color="#CD0000" size="3">可以，在不同的C文件中以static形式来声明同名全局变量</font>。<br>可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="结构体的赋值？"><a href="#结构体的赋值？" class="headerlink" title="结构体的赋值？"></a>结构体的赋值？</h3><p><font color="#CD0000" size="3">C语言中对结构体变量的赋值或者在初始化或者在定义后按字段赋值。</font><br>方式1：初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct tag</span><br><span class="line">&#123;</span><br><span class="line">     char a;</span><br><span class="line">     int b;</span><br><span class="line">&#125;x = &#123;‘A’, 1&#125;;/*初始化*/</span><br><span class="line">或</span><br><span class="line">struct tag</span><br><span class="line">&#123;</span><br><span class="line">char a;</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">struct tag x = &#123;‘A’,1&#125;;/*在定义变量时初始化*/</span><br></pre></td></tr></table></figure></p>
<p>方式2：定义变量后按字段赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct tag</span><br><span class="line">&#123;</span><br><span class="line">char a;</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">struct tag x;/*定义变量*/</span><br><span class="line">x.a =‘A’;/*按字段赋值*/</span><br><span class="line">x.b = 1; /*按字段赋值*/</span><br></pre></td></tr></table></figure></p>
<p>此时使用初始化的方式来赋值时，如x = {‘A’,1};则出错。<br>方式3：结构变量间的赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct tag</span><br><span class="line">&#123;</span><br><span class="line">     chara;</span><br><span class="line">     int b;</span><br><span class="line">&#125;;</span><br><span class="line">struct tag x,y;</span><br><span class="line">x.a=’A’;</span><br><span class="line">x.b=1;</span><br><span class="line">y = x;/*结构变量间直接赋值*/</span><br></pre></td></tr></table></figure></p>
<h3 id="结构体变量如何比较？"><a href="#结构体变量如何比较？" class="headerlink" title="结构体变量如何比较？"></a>结构体变量如何比较？</h3><p>虽然结构体变量之间可以通过=直接赋值，但不能通过比较符（==）来比较，因为比较符只作用于基本数据类型。这个时候，只能通过int memcmp(const void <em>s1, const void </em>s2, size_t n);来进行内存上的比较。</p>
<h3 id="结构体位域"><a href="#结构体位域" class="headerlink" title="结构体位域"></a>结构体位域</h3><p>（1）位域的定义：<br>位域是一个或多个位的字段，不同长度的字段（如声明为unsigned int类型）存储于一个或多个其所声明类型的变量中（如整型变量中）。<br>（2）位域的类型：<br>可以是char、short、int，多数使用int，使用时最好带上signed或unsigned。<br>（3）位域的特点：<br>字段可以不命名，如unsigned int :1;可用来填充；unsigned int :0; 0宽度用来强制在下一个整型（因此处是unsigned int类型）边界上对齐。<br>（4）位域的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct st1</span><br><span class="line">&#123;</span><br><span class="line">unsigned char a:7;/*字段a占用了一个字节的7个bit*/</span><br><span class="line">unsigned char b:2;/*字段b占用了2个bit*/</span><br><span class="line">unsigned char c:7;/*字段c占用了7个bit*/</span><br><span class="line">&#125;s1;</span><br></pre></td></tr></table></figure></p>
<p>sizeof(s1)等于3。因为一个位域字段必须存储在其位域类型的一个单元所占空间中,不能横跨两个该位域类型的单元。也就是说，当某个位域字段正处于两个该位域类型的单元中间时，只使用第二个单元，第一个单元剩余的bit位置补0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct st2</span><br><span class="line">&#123;</span><br><span class="line">unsigned int a:31;</span><br><span class="line">unsigned int b:2;/*前一个整型变量只剩下1个bit，容不下2个bit，所以只能存放在下一个整型变量*/</span><br><span class="line">unsigned int c:31;</span><br><span class="line">&#125;s2;</span><br></pre></td></tr></table></figure></p>
<p>于是可知sizeof(s2)等于3*sizeof(int)即12。<br>（5）位域的好处：<br>a.有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态，用一位二进位即可。这样节省存储空间，而且处理简便。这样就可以把几个不同的对象用一个字节的二进制位域来表示。<br>b.可以很方便的利用位域把一个变量给按位分解。比如只需要4个大小在0到3的随机数，就可以只rand()一次，然后每个位域取2个二进制位即可，省时省空间。<br>（6）位域的缺点：<br>不同系统对位域的处理可能有不同的结果，如位段成员在内存中是从左向右分配的还是从右向左分配的，<font color="#CD0000" size="3">所以位域的使用不利于程序的可移植性</font>。</p>
<h3 id="结构体成员数组大小为0"><a href="#结构体成员数组大小为0" class="headerlink" title="结构体成员数组大小为0"></a>结构体成员数组大小为0</h3><p>结构体数组成员的大小为0是GNU C的一个特性。好处是可以在结构体中分配不定长的大小。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct st</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">int b;</span><br><span class="line">char c[0];</span><br><span class="line">&#125;st_t;</span><br></pre></td></tr></table></figure></p>
<p>sizeof(st_t)等于8，即char c[0]的大小为0。</p>
<h3 id="结构体与联合体的区别？"><a href="#结构体与联合体的区别？" class="headerlink" title="结构体与联合体的区别？"></a>结构体与联合体的区别？</h3><p>（1）结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。<br>（2）对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。</p>
<h2 id="数据类型和函数"><a href="#数据类型和函数" class="headerlink" title="数据类型和函数"></a>数据类型和函数</h2><h3 id="bool，int，float，指针类型的变量a-与0如何比较？"><a href="#bool，int，float，指针类型的变量a-与0如何比较？" class="headerlink" title="bool，int，float，指针类型的变量a 与0如何比较？"></a>bool，int，float，指针类型的变量a 与0如何比较？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）bool :   if ( !a ) or if(a)</span><br><span class="line">（2）int :   if ( a == 0)</span><br><span class="line">（3）float :  const EXPRESSION EXP = 0.000001</span><br><span class="line">          if ( a &lt; EXP &amp;&amp; a &gt;-EXP)</span><br><span class="line">（4）pointer : if ( a != NULL) or if(a == NULL)</span><br></pre></td></tr></table></figure>
<h3 id="函数参数入栈顺序"><a href="#函数参数入栈顺序" class="headerlink" title="函数参数入栈顺序"></a>函数参数入栈顺序</h3><p>C语言函数参数入栈顺序是从右向左的，这是由编译器决定的，更具体的说是函数调用约定决定了参数的入栈顺序。C语言采用是函数调用约定是<strong>cdecl的，所以对于函数的声明，完整的形式是：int </strong>cdecl func(int a, int b);</p>
<h3 id="什么函数不能声明为虚函数？"><a href="#什么函数不能声明为虚函数？" class="headerlink" title="什么函数不能声明为虚函数？"></a>什么函数不能声明为虚函数？</h3><p>Constructor</p>
<h2 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h2><h3 id="“引用”与指针的区别？"><a href="#“引用”与指针的区别？" class="headerlink" title="“引用”与指针的区别？"></a>“引用”与指针的区别？</h3><p>（1）引用必须被初始化，指针不必。<br>（2）引用初始化以后不能被改变，指针可以改变所指的对象。<br>（3）不存在指向空值的引用，但是存在指向空值的指针。<br>（4）指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。<br>（5）流操作符&lt;&lt;和&gt;&gt;、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。</p>
<h3 id="数组与指针的区别？"><a href="#数组与指针的区别？" class="headerlink" title="数组与指针的区别？"></a>数组与指针的区别？</h3><p><font color="#CD0000" size="3">数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</font><br>（1）修改内容上的差别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char a[] = “hello”;</span><br><span class="line">a[0] = ‘X’;</span><br><span class="line">char *p = “world”; // 注意p 指向常量字符串</span><br><span class="line">p[0] = ‘X’; // 编译器不能发现该错误，运行时错误</span><br></pre></td></tr></table></figure></p>
<p>（2）用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//计算数组和指针的内存容量</span><br><span class="line"> char a[] = &quot;hello world&quot;;</span><br><span class="line"> char *p = a;</span><br><span class="line"> cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节</span><br><span class="line"> cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节</span><br></pre></td></tr></table></figure></p>
<p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Func(char a[100])</span><br><span class="line">&#123;</span><br><span class="line"> cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="内存分配回收"><a href="#内存分配回收" class="headerlink" title="内存分配回收"></a>内存分配回收</h2><h3 id="malloc-free与new-delete的区别？"><a href="#malloc-free与new-delete的区别？" class="headerlink" title="malloc/free与new/delete的区别？"></a>malloc/free与new/delete的区别？</h3><p>（1）<font color="#CD0000" size="3">malloc与free是C/C++语言的标准库函数，new/delete是C++的运算符</font>。它们都可用于申请动态内存和释放内存。<br>（2）对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。<br>（3）不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。<br>（4）既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。</p>
<h3 id="malloc-0-返回值是什么？"><a href="#malloc-0-返回值是什么？" class="headerlink" title="malloc(0)返回值是什么？"></a>malloc(0)返回值是什么？</h3><p>如果请求的长度为0，则标准C语言函数malloc返回一个null指针或不能用于访问对象的非null指针，该指针能被free安全使用。</p>
<h3 id="程序的内存分配是怎样的？"><a href="#程序的内存分配是怎样的？" class="headerlink" title="程序的内存分配是怎样的？"></a>程序的内存分配是怎样的？</h3><p>一个由C/C++编译的程序占用的内存分为以下几个部分：<br>（1）<font color="#CD0000" size="3">栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等</font>。其操作方式类似于数据结构中的栈。<br>（2）<font color="#CD0000" size="3">堆区（heap）—一般由程序员分配释放</font>，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。<br>（3）<font color="#CD0000" size="3">全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的</font>，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>（4）<font color="#CD0000" size="3">文字常量区</font>—常量字符串就是放在这里的。程序结束后由系统释放。<br>（5）<font color="#CD0000" size="3">程序代码区</font>—存放函数体的二进制代码<br>例子程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  //main.cpp</span><br><span class="line">  int a=0;    //全局初始化区</span><br><span class="line">  char *p1;   //全局未初始化区</span><br><span class="line">  main()</span><br><span class="line">  &#123;</span><br><span class="line">   intb;栈</span><br><span class="line">   char s[]=&quot;abc&quot;;   //栈</span><br><span class="line">   char *p2;         //栈</span><br><span class="line">   char *p3=&quot;123456&quot;;   //123456\0在常量区，p3在栈上。</span><br><span class="line">   static int c=0；   //全局（静态）初始化区</span><br><span class="line">   p1 = (char*)malloc(10);</span><br><span class="line">   p2 = (char*)malloc(20);  //分配得来得10和20字节的区域就在堆区。</span><br><span class="line">   strcpy(p1,&quot;123456&quot;);   //123456\0放在常量区，编译器可能会将它与p3所向&quot;123456&quot;优化成一个地方。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="堆（heap）和栈-stack-的区别？"><a href="#堆（heap）和栈-stack-的区别？" class="headerlink" title="堆（heap）和栈(stack)的区别？"></a>堆（heap）和栈(stack)的区别？</h3><p>（1）申请方式</p>
<p><font color="#CD0000" size="3">stack:由系统自动分配。</font><br>例如，声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间。</p>
<p><font color="#CD0000" size="3">heap:需要程序员自己申请，并指明大小，在C中用malloc函数</font>，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1=(char*)malloc(10);</span><br></pre></td></tr></table></figure></p>
<p>但是注意p1本身是在栈中的。<br>（2）申请后系统的响应<br>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。<br>（3）申请大小的限制<br>栈：<font color="#CD0000" size="3">在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域</font>。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<br>堆：<font color="#CD0000" size="3">堆是向高地址扩展的数据结构，是不连续的内存区域</font>。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<br>（4）申请效率的比较：</p>
<p><font color="#CD0000" size="3">栈:由系统自动分配，速度较快。但程序员是无法控制的。</font></p>
<p><font color="#CD0000" size="3">堆:是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</font><br>另外，在WINDOWS下，最好的方式是用Virtual Alloc分配内存，他不是在堆，也不是在栈,而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。<br>（5）堆和栈中的存储内容<br>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，<font color="#CD0000" size="3">在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</font><br>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。<br>（6）存取效率的比较<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char s1[]=&quot;aaaaaaaaaaaaaaa&quot;;</span><br><span class="line">char *s2=&quot;bbbbbbbbbbbbbbbbb&quot;;</span><br></pre></td></tr></table></figure></p>
<p>aaaaaaaaaaa是在运行时刻赋值的；<br>而bbbbbbbbbbb是在编译时就确定的；<br>但是，<font color="#CD0000" size="3">在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。</font><br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include</span><br><span class="line">voidmain()</span><br><span class="line">&#123;</span><br><span class="line">char a=1;</span><br><span class="line">char c[]=&quot;1234567890&quot;;</span><br><span class="line">char *p=&quot;1234567890&quot;;</span><br><span class="line">a = c[1];</span><br><span class="line">a = p[1];</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的汇编代码<br>10:a=c[1];<br>004010678A4DF1movcl,byteptr[ebp-0Fh]<br>0040106A884DFCmovbyteptr[ebp-4],cl<br>11:a=p[1];<br>0040106D8B55ECmovedx,dwordptr[ebp-14h]<br>004010708A4201moval,byteptr[edx+1]<br>004010738845FCmovbyteptr[ebp-4],al<br>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。<br>（7）堆栈溢出的原因？</p>
<p><font color="#CD0000" size="3">没有回收垃圾资源；层次太深的递归调用。</font></p>
<h3 id="为什么需要内存对齐？"><a href="#为什么需要内存对齐？" class="headerlink" title="为什么需要内存对齐？"></a>为什么需要内存对齐？</h3><p><font color="#CD0000" size="3">为了提高程序的性能</font>，数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="不能做switch-的参数类型？"><a href="#不能做switch-的参数类型？" class="headerlink" title="不能做switch()的参数类型？"></a>不能做switch()的参数类型？</h3><p>switch的参数不能为实型。</p>
<h3 id="语句for-；1-；-有什么问题？"><a href="#语句for-；1-；-有什么问题？" class="headerlink" title="语句for( ；1 ；)有什么问题？"></a>语句for( ；1 ；)有什么问题？</h3><p>和while(1)相同，无限循环。</p>
<h3 id="do……while和while……do有什么区别？"><a href="#do……while和while……do有什么区别？" class="headerlink" title="do……while和while……do有什么区别？"></a>do……while和while……do有什么区别？</h3><p>前一个循环一遍再判断，后一个判断以后再循环</p>
<h3 id="三种基本的数据模型？"><a href="#三种基本的数据模型？" class="headerlink" title="三种基本的数据模型？"></a>三种基本的数据模型？</h3><p>按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型。</p>
<h3 id="判断一段程序是由C-编译程序还是由C-编译程序编译的？"><a href="#判断一段程序是由C-编译程序还是由C-编译程序编译的？" class="headerlink" title="判断一段程序是由C 编译程序还是由C++编译程序编译的？"></a>判断一段程序是由C 编译程序还是由C++编译程序编译的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">cout&lt;&lt;&quot;c++&quot;;</span><br><span class="line">#else</span><br><span class="line">cout&lt;&lt;&quot;c&quot;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="无限循环的几种写法？"><a href="#无限循环的几种写法？" class="headerlink" title="无限循环的几种写法？"></a>无限循环的几种写法？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）while(1)&#123;&#125;</span><br><span class="line">（2）for(;;)&#123;&#125;</span><br><span class="line">（3）Loop: ... goto Loop;</span><br></pre></td></tr></table></figure>
<h3 id="ASSERT-的作用？"><a href="#ASSERT-的作用？" class="headerlink" title="ASSERT()的作用？"></a>ASSERT()的作用？</h3><p>ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。例如，变量n在程序中不应该为0，如果为0可能导致错误，可以这样写程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">ASSERT( n != 0);</span><br><span class="line">k = 10/ n;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<p>ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。<br>assert()的功能类似，它是ANSI C标准中规定的函数，它与ASSERT的一个重要区别是可以用在Release版本中。</p>
<h3 id="system-“pause”-的作用？"><a href="#system-“pause”-的作用？" class="headerlink" title="system(“pause”);的作用？"></a>system(“pause”);的作用？</h3><p>系统的暂停程序，按任意键继续，屏幕会打印，”按任意键继续。。。。。”省去了使用getchar（）；</p>
<h3 id="C-的类和C里面的struct有什么区别？"><a href="#C-的类和C里面的struct有什么区别？" class="headerlink" title="C++的类和C里面的struct有什么区别？"></a>C++的类和C里面的struct有什么区别？</h3><p>C++中的类具有成员保护功能，并且具有继承，多态这类OO特点，而C里的struct没有。C里面的struct没有成员函数,不能继承,派生等等。</p>
<h3 id="动态连接库的两种方式"><a href="#动态连接库的两种方式" class="headerlink" title="动态连接库的两种方式?"></a>动态连接库的两种方式?</h3><p>（1）<font color="#CD0000" size="3">载入时动态链接</font>（load-time dynamic linking），模块非常明确调用某个导出函数，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向系统提供了载入DLL时所需的信息及DLL函数定位。<br>（2）<font color="#CD0000" size="3">运行时动态链接</font>（run-time dynamic linking），运行时可以通过LoadLibrary或LoadLibraryEx函数载入DLL。DLL载入后，模块可以通过调用GetProcAddress获取DLL函数的出口地址，然后就可以通过返回的函数指针调用DLL函数了。如此即可避免导入库文件了。</p>
<h3 id="程序什么时候应该使用多线程？"><a href="#程序什么时候应该使用多线程？" class="headerlink" title="程序什么时候应该使用多线程？"></a>程序什么时候应该使用多线程？</h3><p>（1）<font color="#CD0000" size="3">耗时的操作</font>使用线程，提高应用程序响应<br>（2）<font color="#CD0000" size="3">并行操作</font>时使用线程，如C/S架构的服务器端并发线程响应用户的请求。<br>（3）<font color="#CD0000" size="3">多CPU系统中</font>，使用线程提高CPU利用率<br>（4）<font color="#CD0000" size="3">改善程序结构</font>。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。<br>其他情况都使用单线程。</p>
<h3 id="多进程与多线程的区别？"><a href="#多进程与多线程的区别？" class="headerlink" title="多进程与多线程的区别？"></a>多进程与多线程的区别？</h3><p>（1）进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。<br>（2）线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。<br>（3）两者都可以提高程序的并发度，提高程序运行效率和响应时间。<br>（4）线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p>
<h3 id="用变量a给出下面的定义"><a href="#用变量a给出下面的定义" class="headerlink" title="用变量a给出下面的定义"></a>用变量a给出下面的定义</h3><p>a) 一个整型数（An integer）<br>b) 一个指向整型数的指针（A pointer to an integer）<br>c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）<br>d) 一个有10个整型数的数组（An array of 10 integers）<br>e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）<br>f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）<br>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）<br>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer<br>argument and return an integer ）<br>答案是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a) int a; // An integer</span><br><span class="line">b) int *a; // A pointer to an integer</span><br><span class="line">c) int **a; // A pointer to a pointer to an integer</span><br><span class="line">d) int a[10]; // An array of 10 integers</span><br><span class="line">e) int *a[10]; // An array of 10 pointers to integers</span><br><span class="line">f) int (*a)[10]; // A pointer to an array of 10 integers</span><br><span class="line">g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer</span><br><span class="line">h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    <div>
    
     <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------The end--Thanks for your reading!-------------</div>
    
</div>
    
    </div>

    

    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">
  <p><span>title:</span>C语言面试基础知识整理</p>
  <p><span>author:</span>weijuanran</p>
  <p><span>pubtime:</span>2018/05/12 - 20:05</p>
  <p><span>update:</span>2018/05/13 - 15:05</p>
  <p><span>original:</span><a href="/C-Language-Interview-Knowldege/" title="C语言面试基础知识整理">http://weijuanran.cn/C-Language-Interview-Knowldege/</a>
    <span class="copy-path"  title="click to copy"><i class="fa fa-clipboard" data-clipboard-text="http://weijuanran.cn/C-Language-Interview-Knowldege/"  aria-label="success！"></i></span>
  </p>
  <p><span>agree:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">Attribution-NonCommercial-NoDerivatives 4.0 International</a></p>  
  <p><span></span> Reprinted please keep the original link and author.</p>
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({   
          title: "",   
          text: 'success',   
          html: false,
          timer: 500,   
          showConfirmButton: false
        });
      });
    }));  
</script>

      
    </div>

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i>C</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Simple-Animation-Tips/" rel="next" title="CSS3-Simple Animation Tips">
                <i class="fa fa-chevron-left"></i> CSS3-Simple Animation Tips
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/C-Language-Interview-Program/" rel="prev" title="C语言面试程序阅读整理">
                C语言面试程序阅读整理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="weijuanran" />
            
              <p class="site-author-name" itemprop="name">weijuanran</p>
              <p class="site-description motion-element" itemprop="description">high infinity</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/weijuanran" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:weijuanran@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/yourname" target="_blank" title="Twitter">
                    
                      <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/u/3515135337" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            
          </div>

          
          

          
          

          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=31654479&auto=0&height=32"></iframe>
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#预处理"><span class="nav-number">1.</span> <span class="nav-text">预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是预编译？何时需要预编译？"><span class="nav-number">1.1.</span> <span class="nav-text">什么是预编译？何时需要预编译？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写一个“标准”宏，这个宏输入两个参数并返回较小的一个"><span class="nav-number">1.2.</span> <span class="nav-text">写一个“标准”宏，这个宏输入两个参数并返回较小的一个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与-的作用？"><span class="nav-number">1.3.</span> <span class="nav-text">#与##的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何避免头文件被重复包含？"><span class="nav-number">1.4.</span> <span class="nav-text">如何避免头文件被重复包含？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#include-与-include-“file-h”的区别？"><span class="nav-number">1.5.</span> <span class="nav-text">#include 与 #include “file.h”的区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字"><span class="nav-number">2.</span> <span class="nav-text">关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#register："><span class="nav-number">2.1.</span> <span class="nav-text">register：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static："><span class="nav-number">2.2.</span> <span class="nav-text">static：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extern："><span class="nav-number">2.3.</span> <span class="nav-text">extern：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const："><span class="nav-number">2.4.</span> <span class="nav-text">const：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typedef："><span class="nav-number">2.5.</span> <span class="nav-text">typedef：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#voliate："><span class="nav-number">2.6.</span> <span class="nav-text">voliate：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inline："><span class="nav-number">2.7.</span> <span class="nav-text">inline：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sizeof："><span class="nav-number">2.8.</span> <span class="nav-text">sizeof：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">3.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全局变量和局部变量在内存中的区别？"><span class="nav-number">3.1.</span> <span class="nav-text">全局变量和局部变量在内存中的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部变量能否和全局变量重名？"><span class="nav-number">3.2.</span> <span class="nav-text">局部变量能否和全局变量重名？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何引用一个已经定义过的全局变量？"><span class="nav-number">3.3.</span> <span class="nav-text">如何引用一个已经定义过的全局变量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局变量能否定义在被多个-C文件包含的头文件中？"><span class="nav-number">3.4.</span> <span class="nav-text">全局变量能否定义在被多个.C文件包含的头文件中？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体"><span class="nav-number">4.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体的赋值？"><span class="nav-number">4.1.</span> <span class="nav-text">结构体的赋值？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体变量如何比较？"><span class="nav-number">4.2.</span> <span class="nav-text">结构体变量如何比较？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体位域"><span class="nav-number">4.3.</span> <span class="nav-text">结构体位域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体成员数组大小为0"><span class="nav-number">4.4.</span> <span class="nav-text">结构体成员数组大小为0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体与联合体的区别？"><span class="nav-number">4.5.</span> <span class="nav-text">结构体与联合体的区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型和函数"><span class="nav-number">5.</span> <span class="nav-text">数据类型和函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bool，int，float，指针类型的变量a-与0如何比较？"><span class="nav-number">5.1.</span> <span class="nav-text">bool，int，float，指针类型的变量a 与0如何比较？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数参数入栈顺序"><span class="nav-number">5.2.</span> <span class="nav-text">函数参数入栈顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么函数不能声明为虚函数？"><span class="nav-number">5.3.</span> <span class="nav-text">什么函数不能声明为虚函数？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组与指针"><span class="nav-number">6.</span> <span class="nav-text">数组与指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#“引用”与指针的区别？"><span class="nav-number">6.1.</span> <span class="nav-text">“引用”与指针的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组与指针的区别？"><span class="nav-number">6.2.</span> <span class="nav-text">数组与指针的区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配回收"><span class="nav-number">7.</span> <span class="nav-text">内存分配回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-free与new-delete的区别？"><span class="nav-number">7.1.</span> <span class="nav-text">malloc/free与new/delete的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-0-返回值是什么？"><span class="nav-number">7.2.</span> <span class="nav-text">malloc(0)返回值是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的内存分配是怎样的？"><span class="nav-number">7.3.</span> <span class="nav-text">程序的内存分配是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆（heap）和栈-stack-的区别？"><span class="nav-number">7.4.</span> <span class="nav-text">堆（heap）和栈(stack)的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么需要内存对齐？"><span class="nav-number">7.5.</span> <span class="nav-text">为什么需要内存对齐？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">8.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不能做switch-的参数类型？"><span class="nav-number">8.1.</span> <span class="nav-text">不能做switch()的参数类型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语句for-；1-；-有什么问题？"><span class="nav-number">8.2.</span> <span class="nav-text">语句for( ；1 ；)有什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do……while和while……do有什么区别？"><span class="nav-number">8.3.</span> <span class="nav-text">do……while和while……do有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三种基本的数据模型？"><span class="nav-number">8.4.</span> <span class="nav-text">三种基本的数据模型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断一段程序是由C-编译程序还是由C-编译程序编译的？"><span class="nav-number">8.5.</span> <span class="nav-text">判断一段程序是由C 编译程序还是由C++编译程序编译的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无限循环的几种写法？"><span class="nav-number">8.6.</span> <span class="nav-text">无限循环的几种写法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASSERT-的作用？"><span class="nav-number">8.7.</span> <span class="nav-text">ASSERT()的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#system-“pause”-的作用？"><span class="nav-number">8.8.</span> <span class="nav-text">system(“pause”);的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-的类和C里面的struct有什么区别？"><span class="nav-number">8.9.</span> <span class="nav-text">C++的类和C里面的struct有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态连接库的两种方式"><span class="nav-number">8.10.</span> <span class="nav-text">动态连接库的两种方式?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序什么时候应该使用多线程？"><span class="nav-number">8.11.</span> <span class="nav-text">程序什么时候应该使用多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多进程与多线程的区别？"><span class="nav-number">8.12.</span> <span class="nav-text">多进程与多线程的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用变量a给出下面的定义"><span class="nav-number">8.13.</span> <span class="nav-text">用变量a给出下面的定义</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">weijuanran</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  visitors:<span id="busuanzi_value_site_pv"></span>
</span>
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v="></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v="></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v="></script>
<script type="text/javascript" src="/js/src/post-details.js?v="></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
<script type="text/javascript" src="/js/src/star.js"></script>
</html>
